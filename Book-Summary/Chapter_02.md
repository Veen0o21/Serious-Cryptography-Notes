## The Nature of Randomness
Randomness is critical throughout cryptography, appearing in secret key generation, encryption schemes, and even in attacks on cryptosystems.
**Without randomness, all cryptographic operations become predictable and, consequently, insecure**.

• Strictly speaking, there is no such thing as a "series of random bits"; rather, **randomness refers to the algorithm or process that produces the bits**.

• A crucial distinction in the field is between something that is _random-looking_ versus something that is _actually random_.
*In cryptography, non-randomness is generally synonymous with insecurity.*

---
## Probability and Entropy
A randomized process is entirely characterized by its **probability distribution**, which lists the possible outcomes and assigns a probability to each.

• **Entropy** is defined as the measure of **uncertainty or disorder** in a system.
It measures the amount of "surprise" found in a randomized process's result; a higher entropy means less certainty.

• The entropy of a distribution is calculated using the negative sum of all probabilities multiplied by their binary logarithm (logarithm in base two). 
The binary logarithm expresses the information in bits.

• Entropy is **maximized when the distribution is uniform** because a uniform distribution maximizes uncertainty.
An n-bit string that is uniformly distributed can have at most n bits of entropy.

• Entropy can also be viewed as a measure of information.

---
## Random Number Generators (RNGs)
The sources of randomness in computing are categorized into Random Number Generators (RNGs) and Pseudorandom Number Generators (PRNGs).

• **RNGs** produce a **few unreliable bits** of randomness typically sourced from analog/physical processes.

• **PRNGs** take these few bits and **expand them into a long stream of reliable, pseudorandom bits**.

• **How PRNGs Work:** A PRNG uses an **entropy pool**, a large memory buffer where incoming random bits (the _seed_ or R) from the RNG are collected and mixed.
This pool is the PRNG's source of entropy.

• The three main operations of a PRNG are:

    1. **init()****:** Resets the PRNG to a fresh state and reinitializes the entropy pool.

    2. **refresh(R)** **(reseeding):** Updates the entropy pool using new data R from the RNG.

    3. **next(N)****:** Returns N pseudorandom bits and updates the entropy pool, ensuring subsequent calls yield different bits.

The `next()` operation runs a DRBG (Deterministic Random Bit Generator).

• The Linux kernel PRNG uses **SHA-1** to convert raw entropy bits into reliable pseudorandom bits, harvesting entropy from sources like interrupt timings, the keyboard, mouse, and disk.

---
## The Fortuna PRNG
Fortuna is a specific PRNG construction designed in 2003 and used in Windows.

• It internally manages **32 entropy pools (**P1​ **through** P32​**)**, structured such that Pi​ is used every 2i reseeds.

• It also maintains a 16-byte key (K) and a 16-byte counter (C) for its internal DRBG state.

• During `next(N)`, it updates K using data from one or more entropy pools.
The required N bits are then generated by encrypting C using K as the key (or C+1, C+2, etc., if needed).

• The implementation of Fortuna is complex, as correctly handling details like entropy pool selection, cipher type, and behavior when entropy is unavailable is challenging, and the specification lacks a comprehensive test suite.

---
## Security Concerns and Implementation Mistakes
The ways randomness implementations can fail:

• **Cryptographic vs. Non-Cryptographic PRNGs:** Cryptographic PRNGs rely on **non-linear equations** (involving AND-combinations or products of bits).
Conversely, non-cryptographic PRNGs (like the Mersenne Twister, MT) are built on **linear combinations** (only using XORs). The linearity makes them cryptographically weak because future states are predictable using simple algebra.

• **Uselessness of Statistical Tests:** Cryptographic PRNGs must be unpredictable, which is a stronger requirement than just passing statistical tests.
Non-cryptographic PRNGs like MT can pass statistical tests perfectly while remaining fundamentally predictable and solvable through linear equations.

• **Poor Entropy Sources:** Systems relying on easily guessed inputs for seeds suffer from severely reduced entropy.
For example, a 1996 Netscape browser implementation used predictable values (time of day, process IDs) for a 128-bit seed, resulting in only about **47 bits of actual entropy**, far below the required security level.

• **Non-Cryptographic PRNG Misuse:** Obsolete versions of the MediaWiki application used the non-crypto Mersenne Twister (`mt_rand()`) to generate security tokens and temporary passwords, allowing researchers to predict future tokens due to MT's predictability.

• **Sampling Bugs:** Even when using a cryptographically strong PRNG, faults in how the random output is sampled can introduce biases.
For instance, the chat program Cryptocat had an off-by-one error in its function to create a uniformly distributed string of decimal digits, causing the generated values to have a biased distribution and lowering the security level.

---
### Analogy to solidify understanding:
*If encryption is like locking a valuable safe, randomness is the high-quality, unique combination code. A strong PRNG is like a highly sophisticated digital machine designed to generate a combination code so complex and unpredictable that trying all possible codes (brute force) would take longer than the age of the universe.*
*A weak, non cryptographic PRNG (like the Mersenne Twister) might generate numbers that look equally random, but it is like a combination lock made of glass—an attacker doesn't need to try the combination; they can simply study the internal mechanism (linearity) and solve it instantly.*

---
